<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trench Wars - Retro Vector Video Game</title>
    <meta name="description" content="Engage in Trench Wars, a retro vector-style arcade game. Pilot your ship through treacherous trenches, destroy enemy TIE fighters, and defend your shields in this classic space shooter experience.">
    <meta name="keywords" content="Trench Wars, Retro Video Game, Vector Graphics, Arcade Game, Space Shooter, Classic Game, HTML5 Game, JavaScript Game">
    <link rel="canonical" href="https://pirillo.com/arcade/trench-wars.html">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/trench-wars.html">
    <meta property="og:title" content="Trench Wars - Retro Vector Video Game">
    <meta property="og:description" content="Engage in Trench Wars, a retro vector-style arcade game. Pilot your ship through treacherous trenches, destroy enemy TIE fighters, and defend your shields in this classic space shooter experience.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/trench-wars.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://pirillo.com/arcade/trench-wars.html">
    <meta property="twitter:title" content="Trench Wars - Retro Vector Video Game">
    <meta property="twitter:description" content="Engage in Trench Wars, a retro vector-style arcade game. Pilot your ship through treacherous trenches, destroy enemy TIE fighters, and defend your shields in this classic space shooter experience.">
    <meta property="twitter:image" content="https://pirillo.com/arcade/images/trench-wars.png">
    <meta name="twitter:creator" content="@ChrisPirillo">

    <link rel="preconnect" href="https://www.googletagmanager.com">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: 'Courier New', Courier, monospace;
            color: #00ff00;
        }
        canvas {
            display: block;
            background: #000;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        canvas.playing {
            cursor: none;
        }
        /* --- Settings Menu Styles --- */
        #settings-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #settings-menu {
            background: #000;
            border: 2px solid #00ffff;
            box-shadow: 0 0 15px #00ffff;
            padding: 20px;
            width: 90%;
            max-width: 750px;
            max-height: 90vh;
            overflow-y: auto;
            color: #fff;
        }
        #settings-menu h1 {
            text-align: center;
            color: #00ff00;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 2em;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        .setting-item {
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            align-items: center;
            gap: 10px;
        }
        .setting-item label {
            color: #00ffff;
            text-transform: uppercase;
            white-space: nowrap;
            text-align: right;
            padding-right: 10px;
        }
        .setting-item input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: #004444;
            outline: none;
            border: 1px solid #00ffff;
        }
        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #ffff00;
            cursor: pointer;
            border: 2px solid #000;
            box-shadow: 0 0 5px #ffff00;
        }
        .setting-item input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #ffff00;
            cursor: pointer;
            border: 2px solid #000;
            box-shadow: 0 0 5px #ffff00;
        }
        .setting-item .value-display {
            color: #ffffff;
            text-align: left;
            min-width: 50px;
        }
        .settings-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 25px;
        }
        .settings-btn {
            background: #111;
            color: #ffff00;
            border: 2px solid #ffff00;
            padding: 10px 15px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            box-shadow: 0 0 5px #ffff00;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .settings-btn:hover {
            background: #ffff00;
            color: #000;
        }
    </style>

    <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "WebPage",
      "name": "Trench Wars - Retro Vector Video Game",
      "description": "Engage in Trench Wars, a retro vector-style arcade game. Pilot your ship through treacherous trenches, destroy enemy TIE fighters, and defend your shields in this classic space shooter experience.",
      "url": "https://pirillo.com/arcade/trench-wars.html",
      "image": "https://pirillo.com/arcade/images/trench-wars.png",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://pirillo.com"
      },
      "keywords": "Trench Wars, Retro Video Game, Vector Graphics, Arcade Game, Space Shooter, Classic Game, HTML5 Game, JavaScript Game"
    }
    </script>
</head>
<body>
    <main>
        <canvas id="gameCanvas" width="800" height="600" aria-label="Trench Wars Game Canvas"></canvas>
    </main>
    
    <div id="settings-overlay" role="dialog" aria-modal="true" aria-labelledby="settings-menu-title">
        <div id="settings-menu">
            <h1 id="settings-menu-title">Trench Wars - Settings</h1>
            <div id="settings-grid" class="settings-grid"></div>
            <div class="settings-buttons">
                <button id="reset-all-btn" class="settings-btn">Reset All</button>
                <button id="apply-btn" class="settings-btn">Apply & Restart</button>
            </div>
        </div>
    </div>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // --- Sound Manager ---
        const soundManager = {
            isInitialized: false,
            isMuted: true, // Start muted by default
            laserSynth: null,
            explosionSynth: null,
            shieldHitSynth: null,
            shieldHitThud: null,

            init: function() {
                // Laser Sound: A lower-pitched "pew pew"
                this.laserSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 10,
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 0.001,
                        decay: 0.4,
                        sustain: 0.01,
                        release: 1.4,
                        attackCurve: 'exponential'
                    }
                }).toDestination();

                // Explosion Sound: A deeper, crunchier boom that lingers
                const explosionReverb = new Tone.Reverb({ decay: 1.5, preDelay: 0.01 }).toDestination();
                const explosionFilter = new Tone.Filter(1200, "lowpass").connect(explosionReverb);
                const distortion = new Tone.Distortion(0.6).connect(explosionFilter);
                this.explosionSynth = new Tone.NoiseSynth({
                    noise: { type: 'brown' },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.8 }
                }).connect(distortion);
                
                // Shield Hit Sound: A proper, loud, crunchy CRASH sound
                const crashCompressor = new Tone.Compressor(-10, 8).toDestination();
                const crashGain = new Tone.Gain(4.0).connect(crashCompressor); // Increased gain
                const crashDistortion = new Tone.Distortion(0.9).connect(crashGain);
                const crashFilter = new Tone.Filter(1500, "lowpass").connect(crashDistortion);

                this.shieldHitSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.4 } // Longer decay/release
                }).connect(crashFilter);

                this.shieldHitThud = new Tone.MembraneSynth({
                    pitchDecay: 0.08,
                    octaves: 2,
                    oscillator: { type: 'fmsquare', harmonicity: 0.8 },
                    envelope: { attack: 0.002, decay: 0.5, sustain: 0, release: 0.5 }
                }).connect(crashFilter);


                this.isInitialized = true;
            },

            playSound: function(sound) {
                if (!this.isInitialized || this.isMuted || Tone.context.state !== 'running') return;

                try {
                    const now = Tone.now();
                    switch(sound) {
                        case 'laser':
                            this.laserSynth.triggerAttackRelease("G3", "8n", now);
                            break;
                        case 'explosion':
                            this.explosionSynth.triggerAttackRelease(0.5, now);
                            break;
                        case 'shieldHit':
                            this.shieldHitSynth.triggerAttackRelease(0.4, now);
                            this.shieldHitThud.triggerAttackRelease("G0", "8n", now, 1.0);
                            break;
                    }
                } catch (error) {
                    console.error("Error playing sound:", error);
                }
            }
        };

        // --- Game State & Settings ---
        let gameState = {};
        let gameSettings = {};
        const SETTINGS_KEY = 'trenchWarsSettings';
        const HIGHSCORE_KEY = 'trenchWarsHighScore';
        let highScore = { score: 0, date: 'N/A' };
        let soundIconRect = {};
        
        // Touch-specific state
        let isTouchAiming = false;
        let lastTouchPosition = { x: 0, y: 0 };
        let lastLaserFireTime = 0;
        const LASER_FIRE_RATE_MS = 150; // Auto-fire rate for touch controls

        const DEFAULT_SETTINGS = {
            enemiesPerWave: { value: 20, min: 5, max: 50, step: 1, name: "Enemies Per Wave" },
            initialSpeed: { value: 1.2, min: 0.5, max: 3, step: 0.1, name: "Initial Speed" },
            waveSpeedScale: { value: 0.3, min: 0.05, max: 1, step: 0.05, name: "Wave Speed Scale" },
            tieSize: { value: 80, min: 40, max: 120, step: 5, name: "TIE Size" },
            tieRoll: { value: 0.002, min: 0, max: 0.01, step: 0.001, name: "TIE Roll Speed" },
            trenchSpeed: { value: 3, min: 1, max: 10, step: 1, name: "Trench Speed" },
            fov: { value: 150, min: 100, max: 300, step: 10, name: "Field of View" },
            shieldHitDistance: { value: -100, min: -150, max: -50, step: 10, name: "Shield Hit Proximity" },
            laserScoreCost: { value: 10, min: 0, max: 50, step: 1, name: "Laser Score Cost" }
        };

        // --- Custom Vector Font ---
        const vectorFont = {
            '0': [[0.2,0,0.8,0],[0.8,0,0.8,1],[0.8,1,0.2,1],[0.2,1,0.2,0]], '1': [[0.5,0,0.5,1]], '2': [[0.2,0,0.8,0],[0.8,0,0.8,0.5],[0.8,0.5,0.2,0.5],[0.2,0.5,0.2,1],[0.2,1,0.8,1]], '3': [[0.2,0,0.8,0],[0.8,0,0.8,1],[0.8,1,0.2,1],[0.2,0.5,0.8,0.5]], '4': [[0.2,0,0.2,0.5],[0.2,0.5,0.8,0.5],[0.8,0,0.8,1]], '5': [[0.8,0,0.2,0],[0.2,0,0.2,0.5],[0.2,0.5,0.8,0.5],[0.8,0.5,0.8,1],[0.8,1,0.2,1]], '6': [[0.8,0,0.2,0],[0.2,0,0.2,1],[0.2,1,0.8,1],[0.8,1,0.8,0.5],[0.8,0.5,0.2,0.5]], '7': [[0.2,0,0.8,0],[0.8,0,0.2,1]], '8': [[0.2,0,0.8,0],[0.8,0,0.8,1],[0.8,1,0.2,1],[0.2,1,0.2,0],[0.2,0.5,0.8,0.5]], '9': [[0.2,1,0.8,1],[0.8,1,0.8,0],[0.8,0,0.2,0],[0.2,0,0.2,0.5],[0.2,0.5,0.8,0.5]], 'A': [[0.0,1.0,0.5,0.0],[0.5,0.0,1.0,1.0],[0.25,0.5,0.75,0.5]], 'B': [[0.0,0.0,0.0,1.0],[0.0,0.0,0.7,0.0],[0.7,0.0,1.0,0.25],[1.0,0.25,0.7,0.5],[0.7,0.5,0.0,0.5],[0.0,0.5,0.7,0.5],[0.7,0.5,1.0,0.75],[1.0,0.75,0.7,1.0],[0.7,1.0,0.0,1.0]], 'C': [[1.0,0.0,0.0,0.0],[0.0,0.0,0.0,1.0],[0.0,1.0,1.0,1.0]], 'D': [[0.0,0.0,0.0,1.0],[0.0,0.0,0.75,0.0],[0.75,0.0,1.0,0.5],[1.0,0.5,0.75,1.0],[0.75,1.0,0.0,1.0]], 'E': [[1.0,0.0,0.0,0.0],[0.0,0.0,0.0,1.0],[0.0,0.5,0.75,0.5],[0.0,1.0,1.0,1.0]], 'F': [[1.0,0.0,0.0,0.0],[0.0,0.0,0.0,1.0],[0.0,0.5,0.75,0.5]], 'G': [[1.0,0.0,0.0,0.0],[0.0,0.0,0.0,1.0],[0.0,1.0,1.0,1.0],[1.0,1.0,1.0,0.5],[1.0,0.5,0.5,0.5]], 'H': [[0.0,0.0,0.0,1.0],[1.0,0.0,1.0,1.0],[0.0,0.5,1.0,0.5]], 'I': [[0.0,0.0,1.0,0.0],[0.5,0.0,0.5,1.0],[0.0,1.0,1.0,1.0]], 'J': [[1.0,0.0,1.0,0.75],[1.0,0.75,0.5,1.0],[0.5,1.0,0.0,0.75]], 'K': [[0.0,0.0,0.0,1.0],[0.0,0.5,1.0,0.0],[0.0,0.5,1.0,1.0]], 'L': [[0.0,0.0,0.0,1.0],[0.0,1.0,1.0,1.0]], 'M': [[0.0,1.0,0.0,0.0],[0.0,0.0,0.5,0.5],[0.5,0.5,1.0,0.0],[1.0,0.0,1.0,1.0]], 'N': [[0.0,0.0,0.0,1.0],[0.0,0.0,1.0,1.0],[1.0,0.0,1.0,1.0]], 'O': [[0.0,0.0,1.0,0.0],[1.0,0.0,1.0,1.0],[1.0,1.0,0.0,1.0],[0.0,1.0,0.0,0.0]], 'P': [[0.0,0.0,0.0,1.0],[0.0,0.0,0.75,0.0],[0.75,0.0,1.0,0.25],[1.0,0.25,0.75,0.5],[0.75,0.5,0.0,0.5]], 'Q': [[0.0,0.0,1.0,0.0],[1.0,0.0,1.0,1.0],[1.0,1.0,0.0,1.0],[0.0,1.0,0.0,0.0],[0.5,0.75,1.0,1.0]], 'R': [[0.0,0.0,0.0,1.0],[0.0,0.0,0.75,0.0],[0.75,0.0,1.0,0.25],[1.0,0.25,0.75,0.5],[0.75,0.5,0.0,0.5],[0.5,0.5,1.0,1.0]], 'S': [[1.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.5],[0.0,0.5,1.0,0.5],[1.0,0.5,1.0,1.0],[1.0,1.0,0.0,1.0]], 'T': [[0.0,0.0,1.0,0.0],[0.5,0.0,0.5,1.0]], 'U': [[0.0,0.0,0.0,0.75],[0.0,0.75,0.25,1.0],[0.25,1.0,0.75,1.0],[0.75,1.0,1.0,0.75],[1.0,0.75,1.0,0.0]], 'V': [[0.0,0.0,0.5,1.0],[0.5,1.0,1.0,0.0]], 'W': [[0.0,0.0,0.25,1.0],[0.25,1.0,0.5,0.5],[0.5,0.5,0.75,1.0],[0.75,1.0,1.0,0.0]], 'X': [[0.0,0.0,1.0,1.0],[1.0,0.0,0.0,1.0]], 'Y': [[0.0,0.0,0.5,0.5],[0.5,0.5,1.0,0.0],[0.5,0.5,0.5,1.0]], 'Z': [[0.0,0.0,1.0,0.0],[1.0,0.0,0.0,1.0],[0.0,1.0,1.0,1.0]], ' ': [], ':': [[0.5,0.25,0.5,0.25],[0.5,0.75,0.5,0.75]], '-': [[0.2,0.5,0.8,0.5]], '.': [[0.5,1,0.5,1]], '!': [[0.5,0,0.5,0.75],[0.5,1,0.5,1]], '?': [[0.2,0,0.8,0],[0.8,0,0.8,0.4],[0.8,0.4,0.5,0.4],[0.5,0.4,0.5,0.7],[0.5,0.9,0.5,0.9]], ',': [[0.5,0.75,0.25,1.0]], "'": [[0.5,0,0.5,0.25]], '"': [[0.25,0,0.25,0.25],[0.75,0,0.75,0.25]], '(': [[0.75,0,0.25,0.5],[0.25,0.5,0.75,1]], ')': [[0.25,0,0.75,0.5],[0.75,0.5,0.25,1]], '+': [[0.5,0,0.5,1],[0,0.5,1,0.5]], '=': [[0,0.3,1,0.3],[0,0.7,1,0.7]], '<': [[0.75,0,0.25,0.5],[0.25,0.5,0.75,1]], '>': [[0.25,0,0.75,0.5],[0.75,0.5,0.25,1]], '/': [[0,1,1,0]], '\\': [[0,0,1,1]], '[': [[0.75,0,0.25,0],[0.25,0,0.25,1],[0.25,1,0.75,1]], ']': [[0.25,0,0.75,0],[0.75,0,0.75,1],[0.75,1,0.25,1]],
        };

        // --- Drawing Functions ---
        function drawVectorText(text, startX, startY, charWidth, charHeight, spacing, strokeStyle, lineWidth) {
            ctx.strokeStyle = strokeStyle; ctx.lineWidth = lineWidth; ctx.lineCap = 'round';
            let currentX = startX;
            for (let i = 0; i < text.length; i++) {
                const char = text[i].toUpperCase(); const segments = vectorFont[char];
                if (segments) {
                    ctx.beginPath();
                    segments.forEach(seg => {
                        ctx.moveTo(currentX + seg[0] * charWidth, startY + seg[1] * charHeight);
                        ctx.lineTo(currentX + seg[2] * charWidth, startY + seg[3] * charHeight);
                    });
                    ctx.stroke();
                }
                currentX += charWidth * 0.8 + spacing;
            }
        }

        // --- Canvas and Resizing ---
        let aspectRatio = 800 / 600; let centerX, centerY;
        function resizeCanvas() {
            const vw = window.innerWidth; const vh = window.innerHeight;
            const availableVh = vh;
            if (vw / availableVh > aspectRatio) { canvas.height = availableVh; canvas.width = availableVh * aspectRatio; } 
            else { canvas.width = vw; canvas.height = vw / aspectRatio; }
            centerX = canvas.width / 2; centerY = canvas.height / 2;
            if (gameState && !gameState.gameOver) { gameState.reticleX = centerX; gameState.reticleY = centerY; }
        }
        window.addEventListener('resize', resizeCanvas);

        // --- Input & Settings Menu Logic ---
        let keys = {};
        const konamiCode = ['arrowup', 'arrowup', 'arrowdown', 'arrowdown'];
        let keySequence = [];

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            keySequence.push(key);
            keySequence = keySequence.slice(-konamiCode.length);
            if (JSON.stringify(keySequence) === JSON.stringify(konamiCode)) {
                toggleSettingsMenu();
            }

            if (key === 'escape') {
                if (document.getElementById('settings-overlay').style.display === 'flex') {
                    toggleSettingsMenu();
                } else if (!gameState.gameOver) {
                    gameState.paused = !gameState.paused;
                    if (gameState.paused) {
                        canvas.classList.remove('playing');
                    } else {
                        canvas.classList.add('playing');
                    }
                }
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        
        // --- MOUSE-ONLY CONTROLS ---
        canvas.addEventListener('pointermove', (e) => {
            if (e.pointerType !== 'mouse' || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width * canvas.width;
            const mouseY = (e.clientY - rect.top) / rect.height * canvas.height;
            gameState.reticleX = mouseX; gameState.reticleY = mouseY;
        });
        
        // --- UNIVERSAL CLICK/TAP HANDLER ---
        canvas.addEventListener('pointerdown', async (e) => {
            if (Tone.context.state !== 'running') {
                await Tone.start();
                console.log('Audio context started!');
                soundManager.init();
            }
            
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) / rect.width * canvas.width;
            const clickY = (e.clientY - rect.top) / rect.height * canvas.height;

            // Check if sound icon was clicked (works for mouse and touch)
            if (clickX >= soundIconRect.x && clickX <= soundIconRect.x + soundIconRect.width &&
                clickY >= soundIconRect.y && clickY <= soundIconRect.y + soundIconRect.height) {
                soundManager.isMuted = !soundManager.isMuted;
                e.preventDefault();
                return;
            }
            
            // Logic below is for MOUSE ONLY
            if (e.pointerType !== 'mouse') return;

            if (gameState.gameOver) {
                restartGame();
            } else if (gameState.paused) {
                gameState.paused = false;
                canvas.classList.add('playing');
            } else {
                gameState.reticleX = clickX;
                gameState.reticleY = clickY;
                fireLaser();
            }
            e.preventDefault();
        });

        // --- TOUCH-ONLY RELATIVE CONTROLS ---
        if (isTouchDevice) {
            window.addEventListener('touchstart', async (e) => {
                // Ignore touch if game is over, paused, or settings are open
                if (gameState.gameOver || gameState.paused || document.getElementById('settings-overlay').style.display === 'flex') return;

                // On game-over screen, a simple tap anywhere should restart
                if (gameState.gameOver) {
                    restartGame();
                    return;
                }

                // First touch might be to unmute or start audio
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log('Audio context started!');
                    soundManager.init();
                }

                e.preventDefault();
                isTouchAiming = true;
                lastTouchPosition.x = e.touches[0].clientX;
                lastTouchPosition.y = e.touches[0].clientY;
            }, { passive: false });

            window.addEventListener('touchmove', (e) => {
                if (!isTouchAiming) return;
                e.preventDefault();

                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;

                const deltaX = currentX - lastTouchPosition.x;
                const deltaY = currentY - lastTouchPosition.y;

                gameState.reticleX += deltaX;
                gameState.reticleY += deltaY;

                // Clamp reticle to canvas bounds
                gameState.reticleX = Math.max(0, Math.min(canvas.width, gameState.reticleX));
                gameState.reticleY = Math.max(0, Math.min(canvas.height, gameState.reticleY));

                lastTouchPosition.x = currentX;
                lastTouchPosition.y = currentY;
            }, { passive: false });

            window.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTouchAiming = false;
            }, { passive: false });
        }
        
        // --- Game Objects ---
        let enemies = []; let lasers = []; let particles = []; let trenchSegments = [];

        // --- 3D Math Utilities ---
        function project3D(x, y, z) {
            const fov = gameSettings.fov.value;
            const currentFov = fov * (canvas.width / 800);
            const scale = currentFov / (currentFov + z);
            return { x: centerX + x * scale, y: centerY + y * scale, scale: scale };
        }
        function rotatePointZ(point, angle) {
            const cos = Math.cos(angle); const sin = Math.sin(angle);
            return { x: point.x * cos - point.y * sin, y: point.x * sin + point.y * cos, z: point.z };
        }

        // --- Classes ---
        class Debris {
            constructor(p1_2d, p2_2d) {
                this.p1 = { x: p1_2d.x, y: p1_2d.y }; this.p2 = { x: p2_2d.x, y: p2_2d.y };
                this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4;
                this.life = 60; this.maxLife = 60;
            }
            update() {
                this.p1.x += this.vx; this.p1.y += this.vy;
                this.p2.x += this.vx; this.p2.y += this.vy;
                this.life--; return this.life > 0;
            }
            draw() {
                const alpha = this.life / this.maxLife; ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y); ctx.lineTo(this.p2.x, this.p2.y); ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }

        class Laser {
            constructor(x, y, z, targetX, targetY, targetZ) {
                this.x = x; this.y = y; this.z = z;
                const dx = targetX - x; const dy = targetY - y; const dz = targetZ - z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                this.vx = (dx / dist) * 80; this.vy = (dy / dist) * 80; this.vz = (dz / dist) * 80;
                this.life = 60;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.z += this.vz;
                this.life--; return this.life > 0;
            }
            draw() {
                const laserLengthFactor = 15;
                const pos1 = project3D(this.x, this.y, this.z);
                const pos2 = project3D(this.x - this.vx * laserLengthFactor, this.y - this.vy * laserLengthFactor, this.z - this.vz * laserLengthFactor);
                if (pos1.scale > 0 && pos2.scale > 0) {
                    ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(pos1.x, pos1.y); ctx.lineTo(pos2.x, pos2.y); ctx.stroke();
                }
            }
        }

        class TIEFighter {
            constructor(x, y, z, speedMultiplier) {
                this.x = x; this.y = y; this.z = z;
                this.vx = (Math.random() - 0.5) * 0.5; this.vy = (Math.random() - 0.5) * 0.2;
                this.vz = -gameSettings.initialSpeed.value * speedMultiplier;
                this.size = gameSettings.tieSize.value;
                this.spawnTime = Date.now(); this.wobbleOffset = Math.random() * Math.PI * 2;
                this.roll = 0; this.rollSpeed = (Math.random() - 0.5) * gameSettings.tieRoll.value;
                this.isAttackable = false;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.z += this.vz;
                this.roll += this.rollSpeed;
                const maxRoll = Math.PI / 32;
                if (this.roll > maxRoll || this.roll < -maxRoll) { this.rollSpeed *= -1; }
                this.x += Math.sin((Date.now() - this.spawnTime) * 0.001 + this.wobbleOffset) * 0.1;
                this.y += Math.cos((Date.now() - this.spawnTime) * 0.0015 + this.wobbleOffset) * 0.05;
                if (Math.random() < 0.005) { this.vx += -this.x * 0.0001; this.vy += -this.y * 0.0001; }
                if (this.z < 1500) { this.isAttackable = true; }
                return this.z > -200;
            }
            draw() {
                const pos = project3D(this.x, this.y, this.z);
                if (pos.scale < 0.01) return;
                const fadeInDistance = 1500;
                let alpha = 1;
                if (this.z > fadeInDistance) { alpha = 1 - ((this.z - fadeInDistance) / 500); alpha = Math.max(0, Math.min(1, alpha)); }
                ctx.globalAlpha = alpha; ctx.strokeStyle = '#00ff00'; ctx.lineWidth = Math.max(1, 2.5 * pos.scale);
                const baseSize = this.size; const cockpitRadius = baseSize * 0.25;
                const wingXOffset = baseSize * 0.5; const wingRadius = baseSize * 0.75;
                const cockpitPoints = [];
                for (let i = 0; i < 6; i++) { const angle = (i / 6) * Math.PI * 2; cockpitPoints.push({ x: Math.cos(angle) * cockpitRadius, y: Math.sin(angle) * cockpitRadius, z: 0 }); }
                const leftWingPoints = []; const rightWingPoints = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const y = Math.sin(angle) * wingRadius; const z = Math.cos(angle) * (wingRadius * 0.2);
                    leftWingPoints.push({ x: -wingXOffset, y, z }); rightWingPoints.push({ x: wingXOffset, y, z });
                }
                const connectorPoints = [
                    { x: -cockpitRadius, y: 0, z: 0 }, { x: -wingXOffset, y: 0, z: 0 },
                    { x: cockpitRadius, y: 0, z: 0 }, { x: wingXOffset, y: 0, z: 0 }
                ];
                const drawShape = (points) => {
                    ctx.beginPath();
                    points.forEach((p, i) => {
                        const rotatedP = rotatePointZ(p, this.roll); const finalP = project3D(this.x + rotatedP.x, this.y + rotatedP.y, this.z + rotatedP.z);
                        if (i === 0) { ctx.moveTo(finalP.x, finalP.y); } else { ctx.lineTo(finalP.x, finalP.y); }
                    });
                    ctx.closePath(); ctx.stroke();
                };
                const drawLines = (points) => {
                     ctx.beginPath();
                     for(let i=0; i < points.length; i+=2) {
                        const p1 = rotatePointZ(points[i], this.roll); const finalP1 = project3D(this.x + p1.x, this.y + p1.y, this.z + p1.z);
                        const p2 = rotatePointZ(points[i+1], this.roll); const finalP2 = project3D(this.x + p2.x, this.y + p2.y, this.z + p2.z);
                        ctx.moveTo(finalP1.x, finalP1.y); ctx.lineTo(finalP2.x, finalP2.y);
                     }
                     ctx.stroke();
                }
                drawShape(cockpitPoints); drawShape(leftWingPoints); drawShape(rightWingPoints); drawLines(connectorPoints);
                ctx.globalAlpha = 1;
            }
            checkCollision(laser) {
                const dx = this.x - laser.x; const dy = this.y - laser.y; const dz = this.z - laser.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const baseRadius = this.size * 0.8; 
                let bonusRadius = 0;
                if (this.z < 600) { bonusRadius = this.size * 0.7 * (1 - this.z / 600); }
                return dist < baseRadius + bonusRadius;
            }
        }

        class TrenchSegment {
            constructor(z) { this.z = z; this.width = 200; this.height = 150; }
            update() { this.z -= gameSettings.trenchSpeed.value; return this.z > -1000; }
            draw() {
                const near = project3D(0, 0, this.z); const far = project3D(0, 0, this.z - 100);
                if (near.scale > 0 && far.scale > 0) {
                    const maxRenderDistance = 1000, fadeStartDistance = 700;
                    let alpha = 1;
                    if (this.z > fadeStartDistance) { alpha = 1 - ((this.z - fadeStartDistance) / (maxRenderDistance - fadeStartDistance)); alpha = Math.max(0, Math.min(1, alpha)); }
                    ctx.globalAlpha = alpha; ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 1;
                    const nearW = this.width * near.scale, nearH = this.height * near.scale;
                    const farW = this.width * far.scale, farH = this.height * far.scale;
                    ctx.beginPath(); ctx.moveTo(centerX - nearW, centerY - nearH); ctx.lineTo(centerX - farW, centerY - farH); ctx.lineTo(centerX - farW, centerY + farH); ctx.lineTo(centerX - nearW, centerY + nearH); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(centerX + nearW, centerY - nearH); ctx.lineTo(centerX + farW, centerY - farH); ctx.lineTo(centerX + farW, centerY + farH); ctx.lineTo(centerX + nearW, centerY + nearH); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(centerX - nearW, centerY + nearH); ctx.lineTo(centerX + nearW, centerY + nearH); ctx.moveTo(centerX - farW, centerY + farH); ctx.lineTo(centerX + farW, centerY + farH); ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }

        // --- Game Logic Functions ---
        function initTrench() {
            trenchSegments = [];
            for (let i = 0; i < 20; i++) { trenchSegments.push(new TrenchSegment(i * 100 + 200)); }
        }
        
        function startNewWave(wave) {
            gameState.wave = wave;
            const speedMultiplier = 1 + (wave - 1) * gameSettings.waveSpeedScale.value;
            for (let i = 0; i < gameSettings.enemiesPerWave.value; i++) {
                const x = (Math.random() - 0.5) * 350;
                const y = (Math.random() - 0.5) * 250;
                const z = 2000 + Math.random() * 1000 + (i * 150);
                enemies.push(new TIEFighter(x, y, z, speedMultiplier));
            }
        }

        const LASER_CANNON_OFFSET_X = 70;
        function fireLaser() {
            if (gameState.gameOver) return;
            soundManager.playSound('laser');
            let laserStartX = gameState.playerX; const laserStartY = gameState.playerY; const laserStartZ = 0;
            if (gameState.currentLaserCannon === 0) { laserStartX = gameState.playerX - LASER_CANNON_OFFSET_X; gameState.currentLaserCannon = 1; } 
            else { laserStartX = gameState.playerX + LASER_CANNON_OFFSET_X; gameState.currentLaserCannon = 0; }
            const targetZ = 1000;
            const targetX = (gameState.reticleX - centerX) / project3D(0,0,targetZ).scale;
            const targetY = (gameState.reticleY - centerY) / project3D(0,0,targetZ).scale;
            lasers.push(new Laser(laserStartX, laserStartY, laserStartZ, targetX, targetY, targetZ));
            gameState.score -= gameSettings.laserScoreCost.value;
            if (gameState.score < 0) gameState.score = 0;
        }
        
        function createExplosion(enemy, playSound = true) {
            if (playSound) {
                soundManager.playSound('explosion');
            }
            const baseSize = enemy.size; const cockpitRadius = baseSize * 0.25;
            const wingXOffset = baseSize * 0.5; const wingRadius = baseSize * 0.75;
            const modelSegments = [];
            for (let i = 0; i < 6; i++) {
                const angle1 = (i / 6) * Math.PI * 2; const angle2 = ((i + 1) / 6) * Math.PI * 2;
                modelSegments.push([ { x: Math.cos(angle1) * cockpitRadius, y: Math.sin(angle1) * cockpitRadius, z: 0 }, { x: Math.cos(angle2) * cockpitRadius, y: Math.sin(angle2) * cockpitRadius, z: 0 } ]);
            }
            [ -wingXOffset, wingXOffset ].forEach(offsetX => {
                for (let i = 0; i < 6; i++) {
                    const angle1 = (i / 6) * Math.PI * 2; const angle2 = ((i + 1) / 6) * Math.PI * 2;
                    modelSegments.push([ { x: offsetX, y: Math.sin(angle1) * wingRadius, z: Math.cos(angle1) * (wingRadius * 0.2) }, { x: offsetX, y: Math.sin(angle2) * wingRadius, z: Math.cos(angle2) * (wingRadius * 0.2) } ]);
                }
            });
            modelSegments.push([ { x: -cockpitRadius, y: 0, z: 0 }, { x: -wingXOffset, y: 0, z: 0 } ]);
            modelSegments.push([ { x: cockpitRadius, y: 0, z: 0 }, { x: wingXOffset, y: 0, z: 0 } ]);
            modelSegments.forEach(segment => {
                const p1_local = segment[0]; const p2_local = segment[1];
                const p1_rolled = rotatePointZ(p1_local, enemy.roll); const p2_rolled = rotatePointZ(p2_local, enemy.roll);
                const p1_world = { x: enemy.x + p1_rolled.x, y: enemy.y + p1_rolled.y, z: enemy.z + p1_rolled.z };
                const p2_world = { x: enemy.x + p2_rolled.x, y: enemy.y + p2_rolled.y, z: enemy.z + p2_rolled.z };
                const p1_2d = project3D(p1_world.x, p1_world.y, p1_world.z);
                const p2_2d = project3D(p2_world.x, p2_world.y, p2_world.z);
                particles.push(new Debris(p1_2d, p2_2d));
            });
        }
        function drawReticle() {
            if (gameState.paused) return;
            ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(gameState.reticleX, gameState.reticleY, 20, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(gameState.reticleX - 30, gameState.reticleY); ctx.lineTo(gameState.reticleX - 15, gameState.reticleY);
            ctx.moveTo(gameState.reticleX + 15, gameState.reticleY); ctx.lineTo(gameState.reticleX + 30, gameState.reticleY);
            ctx.moveTo(gameState.reticleX, gameState.reticleY - 30); ctx.lineTo(gameState.reticleX, gameState.reticleY - 15);
            ctx.moveTo(gameState.reticleX, gameState.reticleY + 15); ctx.lineTo(gameState.reticleX, gameState.reticleY + 30);
            ctx.stroke();
        }
        function updatePlayer() {
            const playerSpeed = 3 * (canvas.width / 800);
            if (keys['w'] || keys['arrowup']) gameState.playerY -= playerSpeed;
            if (keys['s'] || keys['arrowdown']) gameState.playerY += playerSpeed;
            if (keys['a'] || keys['arrowleft']) gameState.playerX -= playerSpeed;
            if (keys['d'] || keys['arrowright']) gameState.playerX += playerSpeed;
            const boundaryX = 150 * (canvas.width / 800);
            const boundaryY = 100 * (canvas.height / 600);
            gameState.playerX = Math.max(-boundaryX, Math.min(boundaryX, gameState.playerX));
            gameState.playerY = Math.max(-boundaryY, Math.min(boundaryY, gameState.playerY));
        }

        function checkAndSaveHighScore() {
            if (gameState.score > highScore.score) {
                highScore.score = gameState.score;
                const today = new Date();
                highScore.date = `${(today.getMonth() + 1).toString().padStart(2, '0')}.${today.getDate().toString().padStart(2, '0')}.${today.getFullYear().toString().slice(-2)}`;
                localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(highScore));
                console.log("New high score saved:", highScore);
            }
        }

        // --- Main Game Loop ---
        function update() {
            if (gameState.gameOver || gameState.paused) return;
            
            // Auto-fire for touch controls
            if (isTouchAiming && (Date.now() - lastLaserFireTime > LASER_FIRE_RATE_MS)) {
                fireLaser();
                lastLaserFireTime = Date.now();
            }

            updatePlayer();
            if (enemies.length === 0) { startNewWave(gameState.wave + 1); }
            if (gameState.damageFlash > 0) gameState.damageFlash--;
            
            enemies = enemies.filter(enemy => {
                const alive = enemy.update();
                if (!alive || enemy.z < gameSettings.shieldHitDistance.value) { 
                    if (enemy.z < gameSettings.shieldHitDistance.value) {
                        soundManager.playSound('shieldHit');
                        gameState.shields -= 10;
                        createExplosion(enemy, false);
                        gameState.damageFlash = 30;
                        if (gameState.shields <= 0) {
                            gameState.gameOver = true;
                            canvas.classList.remove('playing');
                            checkAndSaveHighScore();
                        }
                    }
                    return false;
                }
                return true;
            });

            lasers = lasers.filter(laser => laser.update());
            particles = particles.filter(particle => particle.update());
            trenchSegments = trenchSegments.filter(segment => segment.update());
            if (trenchSegments.length < 20) {
                const lastZ = trenchSegments.length > 0 ? Math.max(...trenchSegments.map(s => s.z)) : 200;
                trenchSegments.push(new TrenchSegment(lastZ + 100));
            }
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (enemy.isAttackable && enemy.checkCollision(laser)) {
                        createExplosion(enemy, true);
                        enemies.splice(j, 1);
                        gameState.score += 100 * gameState.wave;
                        lasers.splice(i, 1);
                        break;
                    }
                }
            }
        }

        // --- CHANGE: Redesigned sound icon and mute slash for better balance ---
        function drawVectorSoundIcon(x, y, size, isMuted, lineWidth) {
            ctx.strokeStyle = '#0077cc';
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'square'; 

            // Speaker body (a simple box)
            ctx.beginPath();
            ctx.rect(x, y + size * 0.25, size * 0.4, size * 0.5);
            ctx.stroke();

            // Speaker horn (an angular shape)
            ctx.beginPath();
            ctx.moveTo(x + size * 0.4, y + size * 0.25);
            ctx.lineTo(x + size * 0.6, y + size * 0.1);
            ctx.lineTo(x + size * 0.6, y + size * 0.9);
            ctx.lineTo(x + size * 0.4, y + size * 0.75);
            ctx.stroke();

            if (!isMuted) {
                 // Sound waves (uniform straight, angular lines)
                const waveStartX = x + size * 0.75;
                const waveLength = size * 0.2;
                
                ctx.beginPath();
                // Top wave
                ctx.moveTo(waveStartX, y + size * 0.3);
                ctx.lineTo(waveStartX + waveLength, y + size * 0.3);
                // Middle wave
                ctx.moveTo(waveStartX, y + size * 0.5);
                ctx.lineTo(waveStartX + waveLength, y + size * 0.5);
                // Bottom wave
                ctx.moveTo(waveStartX, y + size * 0.7);
                ctx.lineTo(waveStartX + waveLength, y + size * 0.7);
                ctx.stroke();

            } else {
                // Mute line: A more balanced slash that covers the speaker graphic
                ctx.beginPath();
                const slashPadding = size * 0.05;
                ctx.moveTo(x + slashPadding, y + slashPadding);
                ctx.lineTo(x + size * 0.6 + slashPadding, y + size - slashPadding);
                ctx.stroke();
            }
        }

        function render() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.paused) {
                trenchSegments.forEach(segment => segment.draw());
                enemies.forEach(enemy => enemy.draw());
                lasers.forEach(laser => laser.draw());
                particles.forEach(particle => particle.draw());
            }

            drawReticle();
            
            const charWidth = 10 * (canvas.width / 800);
            const charHeight = 16 * (canvas.height / 600);
            const charSpacing = 8 * (canvas.width / 800);
            const uiLineWidth = 0.8;
            const uiPaddingX = 20 * (canvas.width / 800);
            const uiPaddingY = 20 * (canvas.height / 600);
            const lineHeight = charHeight * 1.5;
            const labelColor = '#ff00ff'; // Light magenta
            const valueColor = '#ffffff';

            // --- Left-Aligned HUD ---
            const labels = ["SCORE", "SHIELDS", "WAVE"];
            const values = [gameState.score, gameState.shields, gameState.wave];
            const longestLabel = "SHIELDS";
            const labelWidth = longestLabel.length * (charWidth * 0.8 + charSpacing);
            const valueStartX = uiPaddingX + labelWidth + charSpacing; 

            labels.forEach((label, index) => {
                const yPos = uiPaddingY + (lineHeight * index);
                const paddedLabel = label.padStart(longestLabel.length, " ");
                drawVectorText(paddedLabel, uiPaddingX, yPos, charWidth, charHeight, charSpacing, labelColor, uiLineWidth);
                drawVectorText(`${values[index]}`, valueStartX, yPos, charWidth, charHeight, charSpacing, valueColor, uiLineWidth);
            });
            
            // Sound Icon positioned to the top-right
            const iconSize = charHeight * 1.5; // Made icon slightly larger
            const iconX = canvas.width - uiPaddingX - iconSize;
            const iconY = uiPaddingY;
            soundIconRect = { x: iconX, y: iconY, width: iconSize, height: iconSize };
            drawVectorSoundIcon(soundIconRect.x, soundIconRect.y, iconSize, soundManager.isMuted, uiLineWidth * 2);


            if (gameState.damageFlash > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${gameState.damageFlash / 60})`; ctx.fillRect(0, 0, canvas.width, canvas.height); }
            
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.6)'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const gameOverCharWidth = 20 * (canvas.width / 800), gameOverCharHeight = 32 * (canvas.height / 600);
                const restartCharWidth = 12 * (canvas.width / 800), restartCharHeight = 20 * (canvas.height / 600);
                const scoreCharWidth = 10 * (canvas.width / 800), scoreCharHeight = 16 * (canvas.height / 600);
                const verticalGap = 40 * (canvas.height / 600);
                
                const totalHeight = gameOverCharHeight + restartCharHeight + scoreCharHeight + (verticalGap * 2);
                let currentY = centerY - totalHeight / 2;

                const gameOverText = 'GAME OVER';
                const gameOverTextWidth = gameOverText.length * (gameOverCharWidth * 0.8 + 8 * (canvas.width / 800)) - 8 * (canvas.width / 800);
                drawVectorText(gameOverText, centerX - gameOverTextWidth / 2, currentY, gameOverCharWidth, gameOverCharHeight, 8 * (canvas.width / 800), '#ffff00', 1.5);
                currentY += gameOverCharHeight + verticalGap;

                const topScoreText = `TOP SCORE ${highScore.score}`;
                const topScoreTextWidth = topScoreText.length * (scoreCharWidth * 0.8 + 6 * (canvas.width / 800)) - 6 * (canvas.width / 800);
                drawVectorText(topScoreText, centerX - topScoreTextWidth / 2, currentY, scoreCharWidth, scoreCharHeight, 6 * (canvas.width / 800), '#ffffff', 1);
                currentY += scoreCharHeight + verticalGap;
                
                // Change restart text for touch devices
                const restartText = isTouchDevice ? 'TAP TO RUN AGAIN' : 'CLICK TO RUN AGAIN';
                const restartTextWidth = restartText.length * (restartCharWidth * 0.8 + 6 * (canvas.width / 800)) - 6 * (canvas.width / 800);
                drawVectorText(restartText, centerX - restartTextWidth / 2, currentY, restartCharWidth, restartCharHeight, 6 * (canvas.width / 800), '#ffff00', 1);

            } else if (gameState.paused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const pausedCharWidth = 20 * (canvas.width / 800), pausedCharHeight = 32 * (canvas.height / 600);
                const pausedText = 'PAUSED';
                const pausedTextWidth = pausedText.length * (pausedCharWidth * 0.8 + 8 * (canvas.width / 800)) - 8 * (canvas.width / 800);
                drawVectorText(pausedText, centerX - pausedTextWidth / 2, centerY - pausedCharHeight / 2, pausedCharWidth, pausedCharHeight, 8 * (canvas.width / 800), '#ffff00', 1.5);
            }
        }
        function restartGame() {
            canvas.classList.add('playing');
            gameState = {
                shields: 100, score: 0, wave: 0, gameOver: false, paused: false,
                reticleX: centerX, reticleY: centerY, playerX: 0, playerY: 0, playerZ: 0,
                damageFlash: 0, currentLaserCannon: 0
            };
            enemies = []; lasers = []; particles = [];
            initTrench(); startNewWave(1);
        }
        function gameLoop() {
            update(); render();
            requestAnimationFrame(gameLoop);
        }

        // --- Settings Menu Functions ---
        function saveSettings() {
            const settingsToSave = {};
            for (const key in gameSettings) {
                settingsToSave[key] = gameSettings[key].value;
            }
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settingsToSave));
        }
        function loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem(SETTINGS_KEY));
            gameSettings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
            if (savedSettings) {
                for (const key in savedSettings) {
                    if (gameSettings[key]) {
                        gameSettings[key].value = savedSettings[key];
                    }
                }
            }
            const savedHighScore = JSON.parse(localStorage.getItem(HIGHSCORE_KEY));
            if (savedHighScore) {
                highScore = savedHighScore;
            }
        }
        function populateSettingsMenu() {
            const grid = document.getElementById('settings-grid');
            grid.innerHTML = '';
            for (const key in gameSettings) {
                const setting = gameSettings[key];
                const item = document.createElement('div');
                item.className = 'setting-item';
                item.innerHTML = `
                    <label for="${key}-slider">${setting.name}</label>
                    <input type="range" id="${key}-slider" min="${setting.min}" max="${setting.max}" step="${setting.step}" value="${setting.value}">
                    <span id="${key}-value" class="value-display">${setting.value}</span>
                    <button class="settings-btn reset-one-btn" data-key="${key}">Reset</button>
                `;
                grid.appendChild(item);
            }
            for (const key in gameSettings) {
                const slider = document.getElementById(`${key}-slider`);
                const display = document.getElementById(`${key}-value`);
                slider.addEventListener('input', () => { display.textContent = slider.value; });
            }
            document.querySelectorAll('.reset-one-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const key = btn.dataset.key;
                    const defaultValue = DEFAULT_SETTINGS[key].value;
                    document.getElementById(`${key}-slider`).value = defaultValue;
                    document.getElementById(`${key}-value`).textContent = defaultValue;
                });
            });
        }
        function toggleSettingsMenu() {
            const overlay = document.getElementById('settings-overlay');
            const isVisible = overlay.style.display === 'flex';
            overlay.style.display = isVisible ? 'none' : 'flex';
            gameState.paused = !isVisible;
            if (gameState.paused) {
                canvas.classList.remove('playing');
                populateSettingsMenu();
            } else {
                if(soundManager.isInitialized) canvas.classList.add('playing');
            }
        }
        document.getElementById('apply-btn').addEventListener('click', () => {
            for (const key in gameSettings) {
                const slider = document.getElementById(`${key}-slider`);
                gameSettings[key].value = parseFloat(slider.value);
            }
            saveSettings();
            toggleSettingsMenu();
            restartGame();
        });
        document.getElementById('reset-all-btn').addEventListener('click', () => {
            for (const key in DEFAULT_SETTINGS) {
                document.getElementById(`${key}-slider`).value = DEFAULT_SETTINGS[key].value;
                document.getElementById(`${key}-value`).textContent = DEFAULT_SETTINGS[key].value;
            }
        });

        // --- Initialize and Start Game ---
        loadSettings();
        resizeCanvas(); 
        restartGame(); 
        gameLoop();
    </script>
</body>
</html>